# 1208D. Restore Permutation

> time limit: 2s | memory limit: 256mb

An array of integers $p_1,p_2,...,p_n$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3,1,2]$ , $[1]$ , $[1,2,3,4,5]$ and $[4,3,1,2]$. The following arrays are not permutations: $[2]$ , $[1,1]$ , $[2,3,4]$ .

There is a hidden permutation of length $n$.

For each index $i$, you are given $s_i$, which equals to the sum of all $p_j$ such that $j < i$ and $p_j < p_i$ . In other words, $s_i$ is the sum of elements before the $i$-th element that are smaller than the $i$-th element.

Your task is to restore the permutation.

##### Input

The first line contains a single integer $n$ ($1 \leq nâ‰¤\leq 2 \cdot 10^5$) â€” the size of the permutation.

The second line contains $n$ integers $s_1,s_2,...,s_n$ ($0 \leq s_i \leq \frac{ð‘›(ð‘›-1)}{2}$).

It is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.

##### Output

Print $n$ integers $p_1,p_2,...,p_n$ â€” the elements of the restored permutation. We can show that the answer is always unique.

##### Examples

Input
```text
3
0 0 0
```
Output
```text
3 2 1
```

Input
```text
2
0 1
```
Output
```text
1 2
```

Input
```text
5
0 1 1 1 10
```
Output
```text
1 4 3 2 5
```

##### Note

In the first example for each $i$ there is no index $j$ satisfying both conditions, hence $s_i$ are always $0$.

In the second example for $i = 2$ it happens that $j = 1$ satisfies the conditions, so $s_2 = p_1$.

In the third example for $i = 2, 3, 4$ only $j = 1$ satisfies the conditions, so $s_2 = s_3 = s_4 = 1$. For $i = 5$ all $j = 1, 2, 3, 4$ are possible, so $s_5 = p_1 + p_2 + p_3 + p_4 = 10$.

#### é¢˜æ„

æœ‰ä¸€ä¸ªæœªçŸ¥çš„åŽŸåºåˆ—ï¼Œæ˜¯ä¸€ä¸ª $1$ - $n$ çš„æŽ’åˆ—ã€‚çŽ°åœ¨é¢˜ç›®ç»™å‡ºä¸€ä¸ªæ–°çš„åºåˆ—ï¼Œæ–°åºåˆ—çš„ç¬¬ $i$ ä¸ªå…ƒç´ çš„å€¼ä¸ºï¼šåŽŸåºåˆ—ä¸­ï¼Œåœ¨è¿™ä¸ªä½ç½®å·¦ä¾§çš„æ‰€æœ‰æ¯”å®ƒå°çš„æ•°çš„å’Œã€‚çŽ°åœ¨è¦æ±‚æ ¹æ®è¾“å…¥çš„æ–°åºåˆ—ï¼Œæ±‚å‡ºåŽŸåºåˆ—ã€‚

#### è§£æ³•

æ–°åºåˆ—éžå¸¸å®¹æ˜“è®©æˆ‘ä»¬æƒ³åˆ°æ˜¯ä¸€ä¸ªç­‰å·®æ•°åˆ—çš„å’Œï¼Œä½†æ˜¯è¿™ä¸ªç­‰å·®æ•°åˆ—ä¸ä¸€å®šå®Œå…¨ï¼Œä¹Ÿå°±æ˜¯å¯èƒ½ä¼šæœ‰å‡ é¡¹å‡ºçŽ°åœ¨è¯¥æ•°çš„å³ä¾§ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦è€ƒè™‘**ä»Žå³å¾€å·¦**ç¡®å®šæ•´ä¸ªåºåˆ—ã€‚

å¯¹äºŽä¸‹æ ‡ä¸º $n$ çš„ä½ç½®ï¼Œå› ä¸ºæ‰€æœ‰æ¯”è¿™ä¸ªæ•°å°çš„æ•°ä¸€å®šå‡ºçŽ°åœ¨ä»–çš„å·¦ä¾§ï¼Œæ‰€ä»¥æ–°åºåˆ—ä¸­è¿™ä¸ªä½ç½®çš„å€¼ä¸€å®šä¸ºæŸä¸ªæ•°çš„ç­‰å·®å’Œï¼Œå¯¹äºŽè¿™ä¸ªæ•°æˆ‘ä»¬å¯ä»¥ç›´æŽ¥ä½¿ç”¨äºŒåˆ†è¿›è¡ŒæŸ¥æ‰¾ã€‚

ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥ä»Žå³å‘å·¦é€’æŽ¨ï¼Œä¸è¿‡æ­¤æ—¶å‡ºçŽ°ä¸€ä¸ªé—®é¢˜ï¼šåœ¨å³ä¾§ç¡®å®šçš„æ•°ä¼šå½±å“è¯¥ç‚¹çš„å’Œã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ï¼Œç”¨æ¥è®°å½•**åœ¨è¯¥ç‚¹å³ä¾§å‡ºçŽ°è¿‡çš„æ•°çš„å‰ç¼€å’Œ**ã€‚è¿™æ ·æˆ‘ä»¬åœ¨è¿™ä¸ªä½ç½®è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ç­”æ¡ˆæ—¶ï¼Œå¯¹äºŽä¸€ä¸ªå€¼ $mid$ ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ç»“æžœ $cur = sum(mid - 1) - bit.query(mid)$ï¼Œ å…¶ä¸­ $sum(n) = \frac{n(n + 1)}{2}$ ã€‚

æŒ‰ç…§å¸¸è§„çš„äºŒåˆ†æ€è·¯ï¼Œå¦‚æžœ $cur < a[i]$ ï¼Œé‚£ä¹ˆå¾ˆæ˜¾ç„¶æˆ‘ä»¬æŸ¥æ‰¾çš„æ•°åº”è¯¥æ›´å¤§ï¼Œæ­¤æ—¶ $l = mid + 1$ ï¼Œå¦åˆ™ $r = mid - 1$ ã€‚ä¸è¿‡å¯¹äºŽè¿™é“é¢˜æœ‰ä¸€ä¸ªç‰¹åˆ¤æƒ…å†µï¼šå¦‚æžœæ±‚å‡ºçš„ $cur$ æ°å¥½ç­‰äºŽ $a[i]$ ï¼Œä½†æ˜¯è¿™ä¸ªå€¼å·²ç»è¢«ç”¨è¿‡äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ­¤æ—¶åº”è¯¥è®© $l = mid + 1$ ï¼Œå› ä¸ºå¯¹äºŽä¸€ä¸ªæŽ’åˆ—æ˜¯ä¸èƒ½å‡ºçŽ°é‡å¤çš„å…ƒç´ çš„ï¼Œæˆ‘ä»¬è¦æŸ¥æ‰¾çš„ç­”æ¡ˆæ¯”è¿™ä¸ªæ•°æ›´å¤§ä¸€äº›ã€‚

è¿™æ ·æˆ‘ä»¬åªéœ€è¦ä»ŽåŽå¾€å‰ï¼Œå¯¹æ¯ä¸€ä½è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾å³å¯ï¼Œæœ€åŽæ­£å‘è¾“å‡ºç­”æ¡ˆã€‚å› ä¸ºä½¿ç”¨çš„æ˜¯äºŒåˆ†å¥—æ ‘çŠ¶æ•°ç»„çš„åšæ³•ï¼Œæœ€ç»ˆçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log ^2 n)$ ï¼Œå¤æ‚åº¦æ¯”æ ‡è§£å¤šäº†ä¸ª $\log$ ï¼Œä¸è¿‡æ—¶é—´æ˜¯å®Œå…¨è¶³å¤Ÿçš„ï¼Œåªè·‘äº† $140ms$ ã€‚

#### ä»£ç 

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator
 
#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings
 
#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms
 
using namespace std;
 
#define INF 0x3f3f3f3f
#define EPS 1e-8
 
typedef long long ll;
typedef unsigned long long ull;
 
#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)
 
inline ll read()
{
    char ch = getchar();
    ll x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
 
const int MAXN = 200010;
 
ll a[MAXN];
int res[MAXN];
bool vis[MAXN];
 
struct BIT
{
    inline int lowbit(int x) { return x & (-x); }
    int n;
    ll t[MAXN];
    void init(int n)
    {
        this->n = n;
        memset(t + 1, 0, sizeof(t[0]) * n);
    }
    void add(int pos, int v)
    {
        for (; pos <= n; pos += lowbit(pos))
            t[pos] += v;
    }
    ll query(int pos)
    {
        ll res = 0;
        for (; pos > 0; pos -= lowbit(pos))
            res += t[pos];
        return res;
    }
} bit;
 
inline ll sum(int x)
{
    return (ll)x * (x + 1) / 2;
}
 
int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);
 
    int n = read();
 
    bit.init(n);
    memset(vis + 1, 0, sizeof(vis[0]) * n);
 
    rep (i, 1, n)
        a[i] = read();
 
    rep_ (i, n, 1)
    {
        int l = 1, r = n;
        while (l <= r)
        {
            int mid = (l + r) >> 1;
            ll cur = sum(mid - 1) - bit.query(mid - 1);
            if (cur < a[i] || (cur == a[i] && vis[mid]))
                l = mid + 1;
            else
                r = mid - 1;
        }
        res[i] = l;
        vis[l] = true;
        bit.add(l, l);
    }
 
    rep (i, 1, n)
        printf("%d ", res[i]);
    putchar('\n');
 
    return 0;
}
```