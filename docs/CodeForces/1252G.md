# 1252G. Performance Review

> time limit: 2s | memory limit: 256mb

Randall is a software engineer at a company with $N$
employees. Every year, the company re-evaluates its employees. At the end of every year, the company replaces its several worst-performing employees and replaces with the same number of new employees, so that the company keeps having $N$ employees. Each person has a constant performance and can be represented by an integer (higher integer means better performance), and no two people have the same performance.

The performance of the initial employees are represented by an array of integers $A = [A_1, A_2, ..., A_N]$ where $A_i$ is the performance of the $i$-th employee. Randall is employee $1$, so his performance is $A_1$. We will consider the first $M$ years. At the end of the $i$-th year, the company replaces its $R_i$ worst-performing employees and replaces with $R_i$ new employees. The performance of these new employees are represented by an array of integers $B_i = [(B_i)_1, (B_i)_2, ...,(B_i)_{R_i}]$ where $(B_i)_j$ is the performance of the $j$-th new employee.

He will consider $Q$ scenarios. On the $i$-th scenario, he will change the value of $(B_{X_i})_{Y_i}$ to $Z_i$. For each scenario, Randall is wondering whether he will still be in the company after $M$ years. Note that the changes in each scenario are kept for the subsequent scenarios.

##### Input

Input begins with a line containing three integers: $N M Q$ ($2 \leq N \leq 100000$; $1 \leq M, Q \leq 100000$) representing the number of employees, the number of years to be considered, and the number of scenarios, respectively. The next line contains $N$ integers: $A_i$ ($0 \leq A_i \leq 10^9$) representing the performance of the initial employees. The next $M$ lines each contains several integers: $R_i (B_i)_1, (B_i)_2, ..., (B_i)_{R_i}$ ($1 \leq R_i < N$; $0 \leq (B_i)_j \leq 10^9$) representing the number of employees replaced and the performance of the new employees, respectively. It is guaranteed that the sum of $R_i$ does not exceed $10^6$. The next $Q$ lines each contains three integers: $X_i Y_i Z_i$ ($1 \leq X_i \leq ð‘€$; $1 \leq Y_i \leq R(X_i)$; $0 \leq Z_i \leq 10^9$) representing a scenario. It is guaranteed that all integers in all $A_i$, $(B_i)_j$, and $Z_i$ (combined together) are distinct.

##### Output

For each scenario in the same order as input, output in a line an integer $0$ if Randall will not be in the company after ð‘€ years, or 1 if Randall will still be in the company after $M$ years.

##### Example

Input
```text
5 3 3
50 40 30 20 10
4 1 2 3 100
1 4
2 6 7
1 3 300
2 1 400
2 1 5
```
Output
```text
1
0
1
```

##### Note

Explanation for the sample input/output #1

Randall performance is represented by $50$. For the first scenario, the value of $(B_1)_3$ is updated to $300$, causes the following:

-   Initially, the performance of the employees is $[50, 40, 30, 20, 10]$.
-   At the end of the first year, $4$ worst-performing employees are replaced by employees with performance $[300, 100, 2, 1]$. Therefore, the performance of the employees is $[300, 100, 50, 2, 1]$.
-   At the end of the second year, the performance of the employees is $[300, 100, 50, 4, 2]$.
-   At the end of the third year, the performance of the employees is $[300, 100, 50, 7, 6]$.

Therefore, Randall will still be in the company after $3$ years.

For the second scenario, the value of $(B_2)_1$
is updated to $400$, causes the following:

-   Initially, the performance of the employees is $[50, 40, 30, 20, 10]$.
-   At the end of the first year, the performance of the employees is $[300, 100, 50, 2, 1]$. Recall that the change in the first scenario is kept for this scenario as well.
-   At the end of the second year, the performance of the employees is $[400, 300, 100, 50, 2]$.
-   At the end of the third year, the performance of the employees is $[400, 300, 100, 7, 6]$.

Therefore, Randall will not be in the company after $3$ years.

#### é¢˜æ„

ä¸€ä¸ªå…¬å¸ä¸€å¼€å§‹æœ‰ $N$ ä¸ªå‘˜å·¥ï¼Œä»–ä»¬æ¯ä¸ªäººçš„åˆ†æ•°ä¸º $A_i$ ã€‚Randall æ˜¯å…¬å¸åŽŸæ¥çš„ç¬¬ä¸€ä¸ªå‘˜å·¥ã€‚æŽ¥ä¸‹æ¥ä¼šæœ‰ $M$ ä¸ªæœˆï¼Œæ¯ä¸ªæœˆå…¬å¸éƒ½ä¼šå°†ä¸šç»©æœ€å·®çš„ $R_i$ ä¸ªå‘˜å·¥æ›¿æ¢ä¸ºæ–°çš„å‘˜å·¥ï¼Œæ–°å‘˜å·¥çš„åˆ†æ•°åˆ†åˆ«ä¸º $(R_i)_j$ ã€‚

æŽ¥ä¸‹æ¥æœ‰ $Q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡ä¼šå°†ç¬¬ $i$ å¤©çš„ç¬¬ $j$ ä¸ªå‘˜å·¥çš„åˆ†æ•°æ›´æ¢ä¸º $Z_i$ ã€‚ä¿®æ”¹ä¼šä¿ç•™ã€‚çŽ°åœ¨é—®æ¯æ¬¡ä¿®æ”¹ä¹‹åŽï¼Œ Randall æ˜¯å¦åœ¨ $M$ ä¸ªæœˆä¹‹åŽè¿˜èƒ½ç•™åœ¨å…¬å¸å†…ã€‚

#### è§£æ³•

é¦–å…ˆè€ƒè™‘ï¼Œå¦‚æžœ Randall åœ¨ç¬¬ $i$ ä¸ªæœˆä¸ä¼šè¢«æ¢æŽ‰ï¼Œåœ¨ç¬¬ $i$ ä¸ªæœˆçš„æ—¶å€™ï¼Œæ¯” Randall åˆ†æ•°é«˜çš„äººæ•°ä¸èƒ½è¶…è¿‡ $N - R_i - 1$ ï¼Œå¦åˆ™ Randall å°±ä¼šè¢«æ¢ä¸‹ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å…ˆç»Ÿè®¡åˆ°ç¬¬ $i$ ä¸ªæœˆä¸ºæ­¢ï¼Œåˆ†æ•°æ¯” Randall é«˜çš„äººæ•°ã€‚

æŽ¥ä¸‹æ¥è€ƒè™‘æ¯æ¬¡è¯¢é—®çš„ä¿®æ”¹ï¼Œä¸éš¾å‘çŽ°ï¼Œåªæœ‰ä¸¤ç§æƒ…å†µä¸‹ä¼šå¯¹ç»“æžœäº§ç”Ÿå½±å“ï¼Œä¸€ç§æ˜¯åŽŸæ¥æ¯” Randall ä½Žï¼Œä¿®æ”¹åŽæ¯” Randall é«˜ï¼Œå¦ä¸€ç§æ˜¯åŽŸæ¥æ¯” Randall é«˜ï¼Œä¿®æ”¹åŽæ¯”ä»–ä½Žã€‚è€ƒè™‘åˆ°æ¯æ¬¡ä¿®æ”¹å…¶å®žä¹‹ä¼šå¯¹ $[i + 1, M]$ è¿™ä¸ªåŒºé—´äº§ç”Ÿå½±å“ï¼Œè®©æ¯”ä»–é«˜çš„äººæ•° $+1$ æˆ– $-1
$ ï¼Œæ­¤æ—¶å°±å¾ˆå®¹æ˜“æƒ³åˆ°çº¿æ®µæ ‘åšæ³•ã€‚æœ€åŽåªéœ€è¦ç»´æŠ¤åŒºé—´åŠ å‡ä¸ŽåŒºé—´æœ€å¤§/æœ€å°å€¼ï¼Œå°±å¯ä»¥åšå‡ºæ­¤é¢˜ã€‚

#### ä»£ç 

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms

using namespace std;

#define INF 0x3f3f3f3f
#define EPS 1e-8

typedef long long ll;
typedef unsigned long long ull;

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

inline int read()
{
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

const int MAXN = 100010;
int a[MAXN];
vector<int> b[MAXN];

struct segtree
{
    int n;
    int a[MAXN], maxa[MAXN << 2], lazyadd[MAXN << 2];

    #define ls(x) (x << 1)
    #define rs(x) (x << 1 | 1)

    void pushup(int x)
    {
        maxa[x] = max(maxa[ls(x)], maxa[rs(x)]);
    }
    void pushdown(int x, int l, int r)
    {
        if (!lazyadd[x])
            return;
        if (l == r)
        {
            lazyadd[x] = 0;
            return;
        }
        int mid = (l + r) >> 1;
        lazyadd[ls(x)] += lazyadd[x];
        lazyadd[rs(x)] += lazyadd[x];
        maxa[ls(x)] += lazyadd[x];
        maxa[rs(x)] += lazyadd[x];
        lazyadd[x] = 0;
    }
    void build(int n)
    {
        this->n = n;
        build(1, 1, n);
    }
    void build(int x, int l, int r)
    {
        lazyadd[x] = 0;
        if (l == r)
        {
            maxa[x] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(ls(x), l, mid);
        build(rs(x), mid + 1, r);
        pushup(x);
    }
    void add(int tl, int tr, int v)
    {
        add(1, 1, n, tl, tr, v);
    }
    void add(int x, int l, int r, int tl, int tr, int v)
    {
        if (tl <= l && r <= tr)
        {
            maxa[x] += v;
            lazyadd[x] += v;
            return;
        }
        pushdown(x, l, r);
        int mid = (l + r) >> 1;
        if (tl <= mid)
            add(ls(x), l, mid, tl, tr, v);
        if (tr > mid)
            add(rs(x), mid + 1, r, tl, tr, v);
        pushup(x);
    }
    int query(int tl, int tr)
    {
        return query(1, 1, n, tl, tr);
    }
    int query(int x, int l, int r, int tl, int tr)
    {
        if (tl <= l && r <= tr)
            return maxa[x];
        pushdown(x, l, r);
        int mid = (l + r) >> 1;
        int res = 0;
        if (tl <= mid)
            maximize(res, query(ls(x), l, mid, tl, tr));
        if (tr > mid)
            maximize(res, query(rs(x), mid + 1, r, tl, tr));
        return res;
    }
} st;

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n = read(), m = read(), q = read();
    int base = a[1] = read(), cnt = 0;

    rep (i, 2, n)
        a[i] = read(), cnt += a[i] > base;

    rep (i, 1, m)
    {
        int x = read();
        b[i].resize(x + 1);
        st.a[i] = cnt + x;

        rep (j, 1, x)
            b[i][j] = read(), cnt += b[i][j] > base;
    }

    st.build(m);

    rep (_, 1, q)
    {
        int x = read(), y = read(), cur = read(), pre = b[x][y];
        b[x][y] = cur;
        if (pre < base && cur > base && x < m)
            st.add(x + 1, m, +1);
        else if (pre > base && cur < base && x < m)
            st.add(x + 1, m, -1);
        puts(st.query(1, m) < n ? "1" : "0");
    }

    return 0;
}
```