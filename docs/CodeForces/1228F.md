# 1228F. One Node is Gone

> time limit: 1s | memory limit: 256mb

You have an integer $n$. Let's define following tree generation as McDic's generation:

1. Make a complete and full binary tree of $2^n - 1$ vertices. Complete and full binary tree means a tree that exactly one vertex is a root, all leaves have the same depth (distance from the root), and all non-leaf nodes have exactly two child nodes.

2. Select a non-root vertex $v$ from that binary tree.

3. Remove $v$ from tree and make new edges between $v$'s parent and $v$'s direct children. If $v$ has no children, then no new edges will be made. 

You have a tree. Determine if this tree can be made by McDic's generation. If yes, then find the parent vertex of removed vertex in tree.

##### Input

The first line contains integer $n$ ($2 \leq n \leq 17$).

The $i$-th of the next $2^n - 3$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i < b_i \leq 2^n-2$) — meaning there is an edge between $a_i$ and $b_i$. It is guaranteed that the given edges form a tree.

##### Output

Print two lines.

In the first line, print a single integer — the number of answers. If given tree cannot be made by McDic's generation, then print $0$.

In the second line, print all possible answers in ascending order, separated by spaces. If the given tree cannot be made by McDic's generation, then don't print anything.

##### Examples

Input
```text
4
1 2
1 3
2 4
2 5
3 6
3 13
3 14
4 7
4 8
5 9
5 10
6 11
6 12
```
Output
```text
1
3
```

Input
```text
2
1 2
```
Output
```text
2
1 2
```

Input
```text
3
1 2
2 3
3 4
4 5
5 6
```
Output
```text
0
```

##### Note

In the first example, $3$ is the only possible answer.

![Note1](/assets/1228F(1).png)

In the second example, there are $2$ possible answers.

![Note2](/assets/1228F(2).png)

In the third example, the tree can't be generated by McDic's generation.

#### 题意

输入一个包含 $2^n - 3$ 个节点的树，问是否能够通过一个完全二叉树删去一个节点得到这样一棵树，如果可以，输出删除的方案数，以及删除节点的父节点的序号，否则输出 $0$ 。

#### 解法

首先我们需要先考虑：在一个二叉树中删去一个顶点，生成的图有什么样的性质。

1. 如果删除的顶点在根节点下，那么新图将不包含度为 $2$ 的节点。

2. 如果删除的顶点是是中间的节点，那么将会产生一个度为 $4$ 的节点。

3. 如果删除的顶点是叶子节点，那么新图将会有两个度为 $2$ 的节点。

所以首先我们可以对现在这棵树的度进行统计，如果有超过一个度为 $4$ 的点，或是有超过两个度为 $2$ 的点，那么这个树就一定不合法。

接下来，我们对这个树进行拓扑排序，并且记录每个顶点的深度，这样我们就能够找到这个树的重心。

首先，因为这棵树仅为一个完全二叉树删去一个顶点，所以拓扑排序第 $i$ 层的节点个数必定为 $2^{n - i}$ 或是 $2^{n - i} - 1$ ，否则的话也一定不满足条件。

如果图中包含度为 $2$ 的顶点，那么拓扑排序的最终只会剩下一个顶点，并且这个顶点就为原图的根节点。如果图中不包含度为 $2$ 的顶点，那么拓扑排序后最后一层将会存在两个顶点，此时两个顶点都有可能是原图的根节点。接下来，我们从顶点开始构造完全二叉树，填充缺失的顶点，最后判断生成的树是否为完全二叉树即可。

#### 代码

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms

using namespace std;

#define INF 0x3f3f3f3f
#define EPS 1e-8

typedef long long ll;
typedef unsigned long long ull;

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

inline int read()
{
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

const int MAXN = (2 << 17) + 10, MAXM = (2 << 18) + 10;
int h[MAXN], tot = 0;
int deg[MAXN];
int n, N, M;

struct edge
{
    int v, nxt;
} e[MAXM];

void add_edge(int x, int y)
{
    tot++;
    e[tot].v = y;
    e[tot].nxt = h[x];
    h[x] = tot;
}

int dph[MAXN];
int cnt[MAXN];

struct checker
{
    vector<int> G[MAXN];
    bool vis[MAXN];
    bool state;
    int cnt[20];

    checker()
    {
        memclr(vis);
        memclr(cnt);
        state = true;
    }

    void debug()
    {
        rep (i, 1, N + 1)
        for (auto v : G[i])
            printf("%d->%d\n", i, v);
    }

    void build(int u, int sp, int d)
    {   
        vis[u] = true;

        if (u == sp)
        {
            G[u].push_back(N + 1);
            for (int x = h[u]; x; x = e[x].nxt) 
            {
                if (vis[e[x].v])
                    continue;

                if (dph[u] - dph[e[x].v] < d)
                    G[u].push_back(e[x].v);
                else if (dph[u] - dph[e[x].v] == d)
                    G[N + 1].push_back(e[x].v);
                else
                    state = false;
            }
        }
        else
            for (int x = h[u]; x; x = e[x].nxt) 
                if (!vis[e[x].v])
                    G[u].push_back(e[x].v);

        for (int x = h[u]; x; x = e[x].nxt)
            if (!vis[e[x].v])
                build(e[x].v, sp, d);
    }

    void dfs(int u, int dis)
    {
        cnt[dis]++;
        if (G[u].size() != 0 && G[u].size() != 2)
            state = false;
        for (auto v : G[u])
            dfs(v, dis + 1);
    }

    bool check(int rt)
    {
        if (!state)
            return false;
        
        dfs(rt, 0);

        rep (i, 0, n - 1)
            if (cnt[i] != (1 << i))
                state = false;

        return state;
    }
} c1, c2;

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    n = read();
    N = (1 << n) - 2, M = N - 1;

    rep (_, 1, M)
    {
        int u = read(), v = read();
        add_edge(u, v), add_edge(v, u);
        deg[u]++, deg[v]++;
    }

    if (n == 2)
        return puts("2\n1 2") & 0;
    
    int cnt2 = 0, cnt4 = 0, sp2a, sp2b, sp4;
    rep (i, 1, N)
    {
        if (deg[i] == 2)
            cnt2++, sp2b = sp2a, sp2a = i;
        else if (deg[i] == 4)
            cnt4++, sp4 = i;
        else if (deg[i] > 4)
            return puts("0") & 0;
    }

    queue<edge> q;

    rep (i, 1, N)
        if (deg[i] == 1)
        {
            cnt[dph[i] = 1]++;
            for (int x = h[i]; x; x = e[x].nxt)
            {
                if (dph[e[x].v])
                    continue;
                q.push(edge{i, e[x].v});
            }
        }

    int l1, l2;
    while (!q.empty())
    {
        edge cur = q.front(); q.pop();
        deg[cur.nxt]--;

        if (deg[cur.nxt] == 1)
        {
            cnt[dph[cur.nxt] = dph[cur.v] + 1]++, l2 = l1, l1 = cur.nxt;
            
            for (int x = h[cur.nxt]; x; x = e[x].nxt)
            {
                if (dph[e[x].v])
                    continue;
                q.push(edge{cur.nxt, e[x].v});
            }
        }
    }

    // rep (i, 1, N)
    //     printf("%d ", dph[i]);
    // putchar('\n');

    // rep (i, 1, 17)
    //     printf("%d ", cnt[i]);
    // putchar('\n');

    // printf("%d %d %d\n", l1, l2, sp);

    rep (i, 1, n)
        if (cnt[i] != (1 << (n - i)) && cnt[i] + 1 != (1 << (n - i)))
            return puts("0") & 0;

    vector<int> res;

    if (cnt[n]) 
    {
        int sp;
        if (cnt4)
            sp = sp4;
        else
            sp = l1 == sp2a ? sp2b : sp2a;
        
        c1.build(l1, sp, 2);
        if (c1.check(l1))
            res.push_back(sp);
    }
    else
    {
        if (l1 > l2)
            swap(l1, l2);
        c1.build(l1, l1, 1);
        c2.build(l2, l2, 1);
        if (c1.check(l1))
            res.push_back(l1);
        if (c2.check(l2))
            res.push_back(l2);
    }

    if (res.size())
    {
        printf("%d\n", (int)res.size());
        for (auto r : res)
            printf("%d ", r);
        putchar('\n');
    }
    else
        puts("0");

    return 0;
}
```