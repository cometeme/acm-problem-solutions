# 1284D. New Year and Conference

> time limit: 2s | memory limit: 1024mb

Filled with optimism, Hyunuk will host a conference about how great this new year will be!

The conference will have $n$ lectures. Hyunuk has two candidate venues $a$ and $b$. For each of the $n$ lectures, the speaker specified two time intervals $[s_{a_i}, e_{a_i}]$ ($s_{a_i} \leq e_{a_i})$ and $[s_{b_i}, e_{b_i}]$ ($s_{b_i} \leq e_{b_i})$. If the conference is situated in venue $a$, the lecture will be held from $s_{a_i}$ to $e_{a_i}$, and if the conference is situated in venue $ğ‘$, the lecture will be held from $s_{b_i}$ to $e_{b_i}$. Hyunuk will choose one of these venues and all lectures will be held at that venue.

Two lectures are said to overlap if they share any point in time in common. Formally, a lecture held in interval $[x, y]$ overlaps with a lecture held in interval $[u, v]$ if and only if $max(x, u) \leq min(y, v)$.

We say that a participant can attend a subset $s$ of the lectures if the lectures in $s$ do not pairwise overlap (i.e. no two lectures overlap). Note that the possibility of attending may depend on whether Hyunuk selected venue $a$ or venue $b$ to hold the conference.

A subset of lectures $s$ is said to be venue-sensitive if, for one of the venues, the participant can attend $s$, but for the other venue, the participant cannot attend $s$.

A venue-sensitive set is problematic for a participant who is interested in attending the lectures in $s$ because the participant cannot be sure whether the lecture times will overlap. Hyunuk will be happy if and only if there are no venue-sensitive sets. Determine whether Hyunuk will be happy.

##### Input

The first line contains an integer $n$ ($1 \leq n \leq 100000$), the number of lectures held in the conference.

Each of the next $n$ lines contains four integers $s_{a_i}$, $e_{a_i}$, $s_{b_i}$, $e_{b_i}$ ($1 \leq s_{a_i}, e_{a_i}, s_{b_i}, e_{b_i} \leq 10^9$, $s_{a_i} \leq e_{a_i}$, $s_{b_i} \leq e_{b_i}$).

##### Output

Print "YES" if Hyunuk will be happy. Print "NO" otherwise.

You can print each letter in any case (upper or lower).

##### Examples

Input
```text
2
1 2 3 6
3 4 7 8
```
Output
```text
YES
```

Input
```text
3
1 3 2 4
4 5 6 7
3 4 5 5
```
Output
```text
NO
```

Input
```text
6
1 5 2 9
2 4 5 8
3 6 7 11
7 10 12 16
8 11 13 17
9 12 14 18
```
Output
```text
YES
```

##### Note

In second example, lecture set $\{1, 3\}$ is venue-sensitive. Because participant can't attend this lectures in venue $a$, but can attend in venue $b$.

In first and third example, venue-sensitive set does not exist.

#### é¢˜æ„

2020 åˆ°äº†ï¼ŒHyunuk æƒ³è¦ä¸¾åŠä¸€äº›æ´»åŠ¨ï¼Œå…¶ä¸­æ¯ä¸ªæ´»åŠ¨éƒ½å¯ä»¥åœ¨ $a$ æˆ– $b$ ä¸¤ä¸ªåœºæ‰€ä¸¾è¡Œï¼Œåœ¨ $x$ åœºæ‰€ä¸¾è¡Œçš„æ—¶é—´ä¸º $[s_x, e_x]$ ã€‚ç°åœ¨æœ‰ $n$ ä¸ªæ´»åŠ¨ï¼Œåªèƒ½é€‰æ‹©å…¨éƒ¨åœ¨ $a$ åœºé¦†è¿›è¡Œæˆ–æ˜¯å…¨éƒ¨åœ¨ $b$ åœºé¦†è¿›è¡Œã€‚å¦‚æœå­˜åœ¨æŸä¸ªæ´»åŠ¨é›†åˆ $s$ ï¼Œä½¿å¾—åœ¨æŸä¸ªåœºæ‰€å¯ä»¥ä¸å†²çªçš„å‚åŠ é›†åˆä¸­çš„ä¼šè®®ï¼Œè€Œåœ¨å¦ä¸€ä¸ªåœºæ‰€è¿›è¡Œæ—¶ä¼šäº§ç”Ÿå†²çªï¼ˆå†²çªçš„å®šä¹‰æ˜¯æ—¶é—´åŒºé—´ç›¸äº¤ï¼ŒåŒ…æ‹¬ç«¯ç‚¹ï¼‰ï¼Œé‚£ä¹ˆ Hyunuk å°±ä¼šä¸å¼€å¿ƒã€‚ç°åœ¨è¾“å…¥æ‰€æœ‰æ´»åŠ¨ï¼Œé—® Hyunuk æ˜¯å¦å¼€å¿ƒã€‚

#### è§£æ³•

ä¸ºäº†ç®€åŒ–ä¹‹åçš„æè¿°ï¼Œæˆ‘ä»¬å…ˆå®šä¹‰ä¸€ä¸ªæ¦‚å¿µï¼šè‹¥ä¸€ä¸ªæ´»åŠ¨é›†åˆæ˜¯â€œä¸å¥½â€çš„ï¼Œå½“ä¸”ä»…å½“åœ¨è¿™äº›æ´»åŠ¨åœ¨ä¸€ä¸ªåœºæ‰€è¿›è¡Œæ—¶ä¼šäº§ç”Ÿå†²çªï¼Œè€Œåœ¨å¦ä¸€ä¸ªåœºæ‰€è¿›è¡Œåˆ™ä¸ä¼šã€‚é‚£ä¹ˆé¢˜ç›®å°±å¯ä»¥å˜ä¸ºï¼šåˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œä¸å¥½â€çš„æ´»åŠ¨é›†åˆã€‚

é¦–å…ˆæˆ‘ä»¬å°†é—®é¢˜ç®€åŒ–ã€‚åˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œä¸å¥½â€çš„æ´»åŠ¨é›†åˆï¼Œå…¶å®ç­‰ä»·äºåˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œä¸å¥½â€çš„ä¸€å¯¹æ´»åŠ¨ã€‚å› ä¸ºè‹¥æœ‰ä¸€å¯¹æ´»åŠ¨æ˜¯â€œä¸å¥½â€çš„ï¼Œé‚£ä¹ˆå¿…ç„¶ä¼šäº§ç”Ÿå¾ˆå¤šâ€œä¸å¥½â€çš„é›†åˆã€‚åä¹‹ï¼Œè‹¥å­˜åœ¨ä¸€ä¸ªâ€œä¸å¥½â€çš„é›†åˆï¼Œé‚£è¯´æ˜å…¶ä¸­ä¸€å®šå­˜åœ¨ä¸€å¯¹â€œä¸å¥½â€çš„æ´»åŠ¨ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½å°†é—®é¢˜ä»åˆ¤æ–­æ‰€æœ‰é›†åˆå˜ä¸ºåˆ¤æ–­ä»»æ„ä¸¤ä¸ªæ´»åŠ¨æ˜¯å¦æ˜¯â€œä¸å¥½â€çš„ã€‚

ä½†æ˜¯æœ´ç´ çš„åˆ¤æ–­æ–¹æ³•æ˜¯ $O(n^2)$ çš„ï¼Œæ˜¾ç„¶æ— æ³•è¾¾åˆ°é¢˜ç›®æ—¶é™è¦æ±‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦è¿›è¡Œä¼˜åŒ–ã€‚

æˆ‘ä»¬å¯ä»¥è¿™æ ·è€ƒè™‘è¿™ä¸ªé—®é¢˜ï¼šè‹¥æŸäº›æ´»åŠ¨åœ¨ $a$ ä¸­æ˜¯äº’ç›¸å†²çªçš„ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ $b$ ä¸­ä¹Ÿå¿…é¡»äº’ç›¸å†²çªï¼Œè‹¥æŸäº›æ´»åŠ¨åœ¨ $b$ ä¸­æ˜¯äº’ç›¸å†²çªçš„ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ $a$ ä¸­ä¹Ÿå¿…é¡»äº’ç›¸å†²çªã€‚å¦åˆ™å°±å­˜åœ¨ä¸€å¯¹â€œä¸å¥½â€çš„æ´»åŠ¨ï¼Œ Hyunuk å°±ä¼šä¸å¼€å¿ƒã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªé—®é¢˜åˆ†æˆä¸¤ä¸ªç›¸ä¼¼çš„æ“ä½œï¼šåˆ¤æ–­åœ¨ $x$ ä¸­äº’ç›¸å†²çªçš„æ´»åŠ¨ï¼Œæ˜¯å¦åœ¨ $y$ ä¸­ä¹Ÿç›¸äº’å†²çªã€‚å¦‚æœå°† $(a, b)$ å’Œ $(b, a)$ ä»£å…¥éƒ½æ»¡è¶³ï¼Œé‚£ä¹ˆ Hyunuk å°±ä¼šå¼€å¿ƒã€‚

å¦‚ä½•ä¼˜åŒ–è¿™ä¸ªæ“ä½œçš„å¤æ‚åº¦å°±æ¯”è¾ƒå…³é”®ã€‚é¦–å…ˆç”¨æ‰«æçº¿çš„æ–¹æ³•ï¼Œæ‰«æè‡³æ´»åŠ¨ $x_i$ åŒºé—´ ($[s_{x_i}, e_{x_i}]$) çš„å§‹ç«¯ $s_{x_i}$ æ—¶ï¼Œå°†å¯¹åº”çš„åŒºé—´ $y_i$ ($[s_{y_i}, e_{y_i}]$) åŠ å…¥ã€‚æ‰«æè‡³æ´»åŠ¨çš„æœ«ç«¯ $e_{x_i}$ æ—¶ï¼Œå°†å¯¹åº”çš„ $y_i$ åŒºé—´åˆ é™¤ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“æŸä¸ªç‚¹åŒæ—¶åŒ…å«åŒºé—´å¼€å§‹ä¸åŒºé—´ç»“æŸæ—¶ï¼Œéœ€è¦å…ˆå¤„ç†åŒºé—´åŠ å…¥ï¼Œå†åˆ é™¤ã€‚

æ¥ä¸‹æ¥å°±æ˜¯åˆ¤æ–­åŠ å…¥çš„è¿™äº› $y$ åŒºé—´æ˜¯å¦äº’ç›¸é‡åˆã€‚å®è´¨ä¸Šï¼Œè‹¥åŒºé—´ç›¸äº’é‡åˆï¼Œå…¶å®ç­‰ä»·äºåˆ¤æ–­ $max(s_{y_i})$ æ˜¯å¦å°äºç­‰äº $min(e_{y_i})$ ï¼Œä¸ºäº†å¿«é€Ÿæ±‚å‡ºå§‹ç«¯æœ€å¤§å’Œæœ«ç«¯æœ€å°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ª map æ¥è¿›è¡Œè®°å½•ã€‚å…¶ä¸­ map çš„é”®è¡¨ç¤ºä½ç½®ï¼Œè€Œå€¼ä»£è¡¨è¿™ä¸ªä½ç½®æ‰€åŒ…å«çš„ç«¯ç‚¹ä¸ªæ•°ã€‚è¿™æ ·å°±èƒ½å¾ˆå¿«çš„è¿›è¡Œæ·»åŠ ä¸åˆ é™¤ã€‚

æœ€ç»ˆå¯¹ $(a, b)$ å’Œ (b, a)$ éƒ½è¿›è¡Œä¸€æ¬¡éªŒç®—å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n\log n)$ã€‚

#### è§£æ³•

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms

using namespace std;

#define INF 0x3f3f3f3f
#define EPS 1e-8

typedef long long ll;
typedef unsigned long long ull;

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

inline int read()
{
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

struct node
{
    int time, id, state;
};

bool operator<(const node &a, const node &b)
{
    if (a.time != b.time)
        return a.time > b.time;
    else
        return a.state < b.state;
}

const int MAXN = 100010;
int n;
int sa[MAXN], ea[MAXN], sb[MAXN], eb[MAXN];

priority_queue<node> pq;
map<int, int> s, e;

bool solve(int s1[], int e1[], int s2[], int e2[])
{
    while (!pq.empty())  pq.pop();
    s.clear(), e.clear();

    rep (i, 1, n)
        pq.push(node{s1[i], i, 1}), pq.push(node{e1[i], i, -1});

    int cnt = 0;
    while (!pq.empty())
    {
        node cur = pq.top();  pq.pop();
        // printf("time=%d\tid=%d\tstate=%d\n", cur.time, cur.id, cur.state);

        cnt += cur.state;
        s[s2[cur.id]] += cur.state;
        e[e2[cur.id]] += cur.state;
        if (!s[s2[cur.id]])
            s.erase(s2[cur.id]);
        if (!e[e2[cur.id]])
            e.erase(e2[cur.id]);

        if (cnt && (--s.end())->first > e.begin()->first)
            return false;
    }

    return true;
}

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    n = read();

    rep (i, 1, n)
        sa[i] = read(), ea[i] = read(), sb[i] = read(), eb[i] = read();

    bool ok = true;

    ok &= solve(sa, ea, sb, eb);
    ok &= solve(sb, eb, sa, ea);

    puts(ok ? "YES" : "NO");

    return 0;
}
```