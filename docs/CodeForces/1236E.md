# 1236E. Alice and the Unfair Game

> time limit: 1s | memory limit: 256mb

Alice is playing a game with her good friend, Marisa.

There are $n$ boxes arranged in a line, numbered with integers from $1$ to $n$ from left to right. Marisa will hide a doll in one of the boxes. Then Alice will have $m$ chances to guess where the doll is. If Alice will correctly guess the number of box, where doll is now, she will win the game, otherwise, her friend will win the game.

In order to win, Marisa will use some unfair tricks. After each time Alice guesses a box, she can move the doll to the neighboring box or just keep it at its place. Boxes $i$
and $i + 1$ are neighboring for all $1 \leq i \leq n - 1$. She can also use this trick once before the game starts.

So, the game happens in this order: the game starts, Marisa makes the trick, Alice makes the first guess, Marisa makes the trick, Alice makes the second guess, Marisa makes the trick, $...$, Alice makes $m$-th guess, Marisa makes the trick, the game ends.

Alice has come up with a sequence $a_1,a_2,...,a_m$. In the $i$-th guess, she will ask if the doll is in the box $a_i$. She wants to know the number of scenarios $(x, y)$ (for all $1 \leq x, y \leq n$), such that Marisa can win the game if she will put the doll at the ğ‘¥-th box at the beginning and at the end of the game, the doll will be at the $y$-th box. Help her and calculate this number.

##### Input

The first line contains two integers $n$ and $m$, separated by space ($1 \leq n, m \leq 10^5$) â€” the number of boxes and the number of guesses, which Alice will make.

The next line contains $m$ integers $a_1, a_2, ..., a_m$, separated by spaces ($1 \leq a_i \leq n$), the number $a_i$ means the number of the box which Alice will guess in the $i$-th guess.

##### Output

Print the number of scenarios in a single line, or the number of pairs of boxes $(x, y)$ ($1 \leq x, y \leq n$), such that if Marisa will put the doll into the box with number $d$, she can make tricks in such way, that at the end of the game the doll will be in the box with number $y$ and she will win the game.

##### Examples

Input
```text
3 3
2 2 2
```
Output
```text
7
```

Input
```text
5 2
3 1
```
Output
```text
21
```

##### Note

In the first example, the possible scenarios are $(1, 1)$, $(1, 2)$, $(2, 1)$, $(2, 2)$, $(2, 3)$, $(3, 2)$, $(3, 3)$.

Let's take $(2, 2)$ as an example. The boxes, in which the doll will be during the game can be $2 \rightarrow 3 \rightarrow 3 \rightarrow 3 \rightarrow 2$

#### é¢˜æ„

æœ‰ $n$ ä¸ªç›’å­ï¼Œä¸€å¼€å§‹ Alice ä¼šåœ¨æŸä¸€ä¸ªç›’å­ä¸­æ”¾ä¸€ä¸ªç©å¶ã€‚ç„¶å Marisa ä¼šè¿›è¡Œ $m$ æ¬¡çŒœæµ‹ï¼Œæ¯ä¸€æ¬¡çŒœæµ‹çš„ä½ç½®æ˜¯å·²çŸ¥çš„ã€‚ç°åœ¨ Alice èƒ½åœ¨æ¸¸æˆä¸€å¼€å§‹ï¼Œå’Œ Marisa æ¯ä¸€æ¬¡çŒœæµ‹åäº¤æ¢ä¸€ç»„ç›¸é‚»çš„ç›’å­çš„ä½ç½®ã€‚å› ä¸º Alice çŸ¥é“ Marisa è¦çŒœå“ªä¸ªä½ç½®ï¼Œæ‰€ä»¥å¥¹å¯ä»¥ä¸è®© Marisa çŒœåˆ°å«æœ‰ç©å¶çš„ç®±å­ã€‚ç°åœ¨é—®ä»¥ç©å¶æ‰€åœ¨ç›’å­çš„èµ·ç‚¹ã€ç»ˆç‚¹ç»„æˆçš„å¯¹æœ‰å¤šå°‘ä¸ªã€‚

#### è§£æ³•

é¦–å…ˆå¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ª $(m + 2) \times n$ çš„çŸ©é˜µã€‚å…¶ä¸­ç¬¬ $i$ æ¬¡çŒœæµ‹ $a_i$ ä½ç½®ï¼Œç­‰ä»·äºå°†è¿™ä¸ªçŸ©é˜µçš„ç¬¬ $i + 1$ è¡Œç¬¬ $a_i$ ä¸ªä½ç½®è®¾ç½®ä¸ºéšœç¢ç‰©ï¼Œè€Œæ¯æ¬¡å‘ä¸‹è½¬ç§»æ—¶ï¼Œç©å¶å¯ä»¥åœç•™åœ¨åŸåœ°ï¼Œä¹Ÿå¯ä»¥å‘å·¦æˆ–å‘å³ç§»åŠ¨ä¸€æ ¼ã€‚æœ€ç»ˆå°±å¯ä»¥å˜ä¸ºæ±‚æ¯ä¸ªèµ·ç‚¹èƒ½å¤Ÿåˆ°è¾¾çš„ç»ˆç‚¹æ•°ï¼Œæœ€åæ±‚å’Œã€‚

é¦–å…ˆè€ƒè™‘ï¼šå¦‚æœä¸å­˜åœ¨éšœç¢ç‰©ï¼Œé‚£ä¹ˆæ¯ä¸ªèµ·ç‚¹èƒ½å¤Ÿåˆ°è¾¾çš„ä½ç½®ä¸ºä¸€ä¸ªä¸‰è§’å½¢ã€‚è€Œå¦‚æœåªåœ¨ä¸­é—´å‡ºç°äº†éšœç¢ç‰©ï¼Œé‚£ä¹ˆæ˜¯ä¸ä¼šå½±å“æœ€åèƒ½å¤Ÿåˆ°è¾¾çš„ç»ˆç‚¹æ•°çš„ã€‚ç„¶è€Œï¼Œå¦‚æœæœ‰ä¸€äº›éšœç¢ç‰©å‡ºç°åœ¨æœ€å¤–ä¾§çš„è¾¹ç•Œï¼Œé‚£ä¹ˆå°±ä¼šå°†è¿™ä¸ªä¸‰è§’å½¢æŒ¡ä½ï¼Œå¦‚ä¸‹å›¾ä¸‰ç§æƒ…å†µæ‰€ç¤ºï¼š

![Note](/assets/1236E.png)

å¯ä»¥å‘ç°ï¼Œæœ€å³è¾¹çš„ç›´çº¿è¢«è¿ç»­é®æŒ¡äº†ä¸¤æ¬¡ï¼Œæ‰€ä»¥ç­”æ¡ˆä¹Ÿç¼©å°äº† $2$ ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ dsu ï¼Œå¤„ç†å‘å·¦ä¸‹å’Œå³ä¸‹ä¸¤ä¸ªæ–¹å‘æŠ•å½±æ—¶éšœç¢ç‰©çš„è¿ç»­é®æŒ¡æƒ…å†µï¼Œç„¶åå¯¹äºæ¯ä¸ªèµ·ç‚¹å°±å¯ä»¥ $O(1)$ è®¡ç®—å‡ºå®ƒèƒ½å¤Ÿåˆ°è¾¾çš„ç»ˆç‚¹çš„èŒƒå›´ã€‚

#### ä»£ç 

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms

using namespace std;

#define INF 0x3f3f3f3f
#define EPS 1e-8

typedef long long ll;
typedef unsigned long long ull;

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

inline int read()
{
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

const int MAXN = 100010;

struct dsu
{
    int nd[MAXN];
    void init(int n)
    {
        for (int i = 0; i <= n; i++)
            nd[i] = i;
    }
    int find(int x)
    {
        return nd[x] == x ? x : nd[x] = find(nd[x]);
    }
    void merge(int a, int b)
    {
        nd[find(a)] = find(b);
    }
    bool connected(int a, int b)
    {
        return find(a) == find(b);
    }
}d[2];

map<int, vector<int> > a[2];
int b[MAXN];

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n = read(), m = read();
    
    d[0].init(m + 1);
    d[1].init(m + 1);

    rep (i, 1, m)
    {
        b[i] = read();
        a[0][b[i] - i].push_back(i);
        a[1][b[i] + i].push_back(i);
    }

    if (n == 1)
        return puts("0") & 0;

    rep (i, 0, 1)
        for (auto kv : a[i])
        {
            int p1 = kv.first;
            int p2 = i ? p1 + 1 : p1 - 1;
            if (!a[i].count(p2))
                continue;
            vector<int> &v1 = kv.second;
            vector<int> &v2 = a[i][p2];
            for (auto x : v1)
            {
                auto it = upper_bound(v2.begin(), v2.end(), x);
                if (it == v2.end())
                    break;
                // printf("%d %d\n", x, *it);
                d[i].merge(x, *it);
            }
        }
    
    ll res = 0;
    rep (i, 1, n)
    {
        int l = i - m - 1, r = i + m + 1;
        if (a[1].count(i))
        {
            int x = a[1][i][0];
            int y = d[1].find(x);
            int dis = (b[y] + y) - (b[x] + x) + 1;
            l += dis;
        }
        if (a[0].count(i))
        {
            int x = a[0][i][0];
            int y = d[0].find(x);
            int dis = (b[x] - x) - (b[y] - y) + 1;
            r -= dis;
        }
        l = max(l, 1);
        r = min(r, n);
        res += r - l + 1;
    }

    printf("%lld\n", res);

    return 0;
}
```