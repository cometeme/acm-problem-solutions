# 1182F. Maximum Sine

> time limit: 3s | memory limit: 256mb

You have given integers $a$, $b$, $p$, and $q$. Let $f(x)=abs(sin(\frac{p}{q} \pi x))$.

Find minimum possible integer $x$ that maximizes $f(x)$ where $a \leq x \leq b$.

##### Input

Each test contains multiple test cases.

The first line contains the number of test cases $t$ ($1 \leq t \leq 100$) â€” the number of test cases.

The first line of each test case contains four integers $a$, $b$, $p$, and $q$ ($0 \leq a \leq b \leq 10^9$, $1 \leq ğ‘, q \leq 10^9$).

##### Output

Print the minimum possible integer $x$ for each test cases, separated by newline.

##### Example

Input
```text
2
0 3 1 3
17 86 389 995
```
Output
```text
1
55
```

##### Note

In the first test case, $f(0)=0$, $f(1)=f(2) \approx 0.866$, $f(3)=0$.

In the second test case, $f(55) \approx 0.999969$, which is the largest among all possible values.

#### é¢˜æ„

é¢˜ç›®ç»™å®šä¸€ç»„ $p, q$ å’Œä¸€ä¸ªåŒºé—´ $[a, b]$ ï¼Œç°åœ¨è¦æ±‚ä»åŒºé—´ä¸­æ‰¾åˆ°ä¸€ä¸ªæ•° $x$ ï¼Œä½¿å¾— $f(x)=abs(sin(\frac{p}{q} \pi x))$ çš„å€¼æœ€å¤§ã€‚å¦‚æœå­˜åœ¨å¤šä¸ª $x$ åˆ™è¾“å‡ºæœ€å°çš„é‚£ä¸€ä¸ªã€‚

#### è§£æ³•

~~å…¶å®åœ¨çœ‹é¢˜è§£ä¹‹å‰ï¼Œæˆ‘ä¸€ç›´ä»¥ä¸ºæˆ‘çš„åšæ³•ä¸æ˜¯æ ‡ç¨‹åšæ³•~~

å…ˆè§‚å¯Ÿ $abs(sin(t))$ è¿™ä¸ªå‡½æ•°çš„æ€§è´¨ï¼šå½“ $t$ è¶Šæ¥è¿‘äº $\frac{\pi}{2} + k \pi$ æ—¶ï¼Œå‡½æ•°çš„å€¼ä¹Ÿå°±è¶Šå¤§ã€‚å¯¹äºé¢˜ç›®è€Œè¨€ï¼Œ $f(x)=abs(sin(\frac{p}{q} \pi x))$ çš„å€¼è¶Šå¤§ï¼Œä¹Ÿå°±æ„å‘³ç€ $\frac{p}{q} \pi x$ çš„å€¼è¶Šæ¥è¿‘äº $\frac{\pi}{2} + k \pi$ ï¼Œå³ $(\frac{p}{q} \pi x) \mod \pi$ çš„å€¼è¶Šæ¥è¿‘ $\frac{\pi}{2}$ ã€‚å†å°†è¿™ä¸ªå¼å­åŒ–è§£ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° $2px \mod 2q$ **éœ€è¦å°½å¯èƒ½æ¥è¿‘** $q$ã€‚

å› ä¸ºæ­¤æ—¶è€ƒè™‘å°†åŒºé—´åˆ‡å—ï¼Œå…·ä½“åˆ†å—çš„å¤§å°å…¶å®æ˜¯ä»»æ„çš„ï¼Œä¸è¿‡ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å°†åŒºé—´åˆ†ä¸º $\sqrt{bâˆ’a+1}$ çš„å¤§å°ã€‚ä¸€èˆ¬æƒ…å†µä¸‹æœ€åä¸€ä¸ªåºåˆ—çš„é•¿åº¦æ˜¯ä¸åˆ° $\sqrt{bâˆ’a+1}$ çš„ï¼Œæ‰€ä»¥åœ¨æœ€åæˆ‘ä»¬å•ç‹¬å¤„ç†è¿™ä¸€ä¸ªå—ã€‚

æ­¤æ—¶æˆ‘ä»¬å°±å¾—åˆ°äº† $\sqrt{bâˆ’a+1}$ ä¸ªåŒºå— (å…ˆå‡è®¾æœ€åä¸€ä¸ªå—çš„å¤§å°æ­£å¥½ä¹Ÿä¸º $\sqrt{bâˆ’a+1}$) ï¼Œå°†æ¯ä¸ªå—çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ‹¿å‡ºæ¥ã€‚ä¹‹åæˆ‘ä»¬è®¡ç®—è¿™äº›å…ƒç´  $2px \mod 2q$ çš„å€¼ï¼Œæ”¾åœ¨ä¸€ä¸ªæ–°çš„åºåˆ—ä¸­ï¼Œå¹¶è¿›è¡Œæ’åºã€‚

æ’åºåï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°è¿™ä¸ªåºåˆ—ä¸­æœ€æ¥è¿‘ $q$ çš„å…ƒç´ ï¼Œæ­¤æ—¶å°±å¯ä»¥è¿›è¡ŒäºŒåˆ†äº†ï¼Œå¹¶ä¸”æ›´æ–°ä¸€ä¸‹ç­”æ¡ˆã€‚

è¿›è¡Œå®Œè¿™ä¸€æ­¥ä¹‹åï¼Œæˆ‘ä»¬å°†æ¯ä¸ªåˆ†å—ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´ å–å‡ºæ¥ï¼Œå†é‡å¤ä¸Šè¿°çš„è¿‡ç¨‹ã€‚ç„¶åã€‚ã€‚ã€‚å°±ä¼š TLE äº†ã€‚å› ä¸ºè¿™æ ·å¤æ‚åº¦å°±é€€åŒ–åˆ°äº† $O(nlog\sqrt{n})$ã€‚

è®©æˆ‘ä»¬é‡æ–°è€ƒè™‘è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å–å‡ºä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œé‡æ–°æ”¾äºåºåˆ—ä¸­ï¼Œå…¶å®ä¹Ÿå°±æ˜¯å°†åŸæ¥åºåˆ—ä¸­çš„ $x$ æ›¿æ¢ä¸º $x+i$ ï¼Œä¹Ÿå°±æ˜¯é—®é¢˜å˜ä¸ºäº† $(2px + 2pi) \mod 2q$ æ›´æ¥è¿‘äº $q$ ã€‚ä¹‹åå¯ä»¥å˜ä¸º $2px \mod 2q$ æ›´æ¥è¿‘äº $q - (2pi \mod 2q)$ ï¼Œæœ€ç»ˆå³ä¾§å¯ä»¥å˜ä¸º $(q - 2pi) \mod 2q$ ï¼Œè¿™æ ·å°±å¯ä»¥å¤„ç†ä¸ºè´Ÿçš„æƒ…å†µã€‚è¿™æ ·åšï¼Œæˆ‘ä»¬å°±**ä¸éœ€è¦ä¿®æ”¹åŸåºåˆ—**ï¼Œåªéœ€è¦åœ¨äºŒåˆ†æ—¶ä¿®æ”¹æœç´¢çš„ç›®æ ‡å³å¯ã€‚å¤æ‚åº¦é™ä¸ºäº† $O(\sqrt{n}log\sqrt{n})$ ã€‚

å½“ç„¶ï¼Œæœ€åè¿˜æœ‰ä¸ªå°é—®é¢˜ï¼Œå°±æ˜¯æœ€åä¸€ä¸ªåˆ†å—çš„é•¿åº¦ä¸€èˆ¬ä¸ä¼šåˆšå¥½æ˜¯ $\sqrt{bâˆ’a+1}$ ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å¾ªç¯æ—¶åˆ¤æ–­ä¸€ä¸‹å½“å‰çš„ä½ç½®ï¼Œå¦‚æœè¶…è¿‡äº†æœ€åä¸€ä¸ªå—çš„é•¿åº¦å°±å¯¹å…¶è¿›è¡Œç‰¹æ®Šå¤„ç†å³å¯ã€‚

ä¸è¿‡ $O(\sqrt{n}log\sqrt{n})$ çš„å¤æ‚åº¦æ€ä¹ˆçœ‹éƒ½ä¸æ˜¯å¾ˆä¼˜é›…ã€‚åœ¨ç¿»é¢˜è§£çš„è¿‡ç¨‹ä¸­çœ‹åˆ°äº†å…¶ä»–å¤§ä½¬ä»¬ç”¨çš„ç«Ÿç„¶æ˜¯ç±»æ¬§çš„ç®—æ³•ï¼Œæœ€ç»ˆçš„å¤æ‚åº¦å¯ä»¥è¾¾åˆ° $O(log^2n)$ ï¼Œè¿˜æ˜¯è†œä¸€ä¸‹[AThousandMoons å¤§ä½¬çš„é¢˜è§£](https://www.cnblogs.com/AThousandMoons/p/11108875.html)ã€‚

#### ä»£ç 

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <algorithm> // Algorithms

using namespace std;

#define INF 0x007F7F7F7F7F7F7FLL
#define EXP 1e-8

#define ll long long

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

const int MAXN = 100010;

struct node
{
    ll v;
    ll id;
    node(ll v, ll id)
    {
        this->v = v;
        this->id = id;
    }
    node()
    {
    }
};

bool operator<(node A, node B)
{
    if (A.v == B.v)
        return A.id < B.id;
    else
        return A.v < B.v;
}

node a[MAXN];

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    int T;
    cin >> T;

    rep (k, 1, T)
    {
        ll l, r, p, q;
        cin >> l >> r >> p >> q;

        ll step = sqrt(r - l + 1), tot = 0, val = INF, ans = -INF;
        ll p2 = 2LL * p, q2 = 2LL * q;

        reps (i, l, r, step)
        {
            if (i + step - 1 <= r)
            {
                tot++;
                a[tot] = node(i * p2 % q2, i);
            }
            else
            {
                rep (j, i, r)
                {
                    ll cur = abs(j * p2 % q2 - q);
                    if (cur < val || (cur == val && j < ans))
                    {
                        val = cur;
                        ans = j;
                    }
                }
            }
        }

        sort(a + 1, a + 1 + tot);
        ll tot2 = 1;

        rep (i, 2, tot)
            if (a[i].v != a[tot2].v)
            {
                tot2++;
                a[tot2] = a[i];
            }

        ll cur = 0;
        rep (i, 0, step - 1)
        {
            ll pos = (q - cur + q2) % q2;
            int k = lower_bound(a + 1, a + 1 + tot2, node(pos, -INF)) - a;

            if (k <= tot2)
            {
                if (a[k].v - pos < val || (a[k].v - pos == val && a[k].id + i < ans))
                {
                    val = a[k].v - pos;
                    ans = a[k].id + i;
                }
            }
            else
            {
                if (q2 - (pos - a[1].v) < val || (q2 - (pos - a[1].v) == val && a[1].id + i < ans))
                {
                    val = q2 - (pos - a[1].v);
                    ans = a[1].id + i;
                }
            }

            k--;
            // Calculate remain part
            if (k >= 1)
            {
                if (pos - a[k].v < val || (pos - a[k].v == val && a[k].id + i < ans))
                {
                    val = pos - a[k].v;
                    ans = a[k].id + i;
                }
            }
            else
            {
                if (q2 - (a[tot2].v - pos) < val || (q2 - (a[tot2].v - pos) == val && a[tot2].id + i < ans))
                {
                    val = q2 - (a[tot2].v - pos);
                    ans = a[tot2].id + i;
                }
            }

            cur = (cur + p2) % q2;
        }

        cout << ans << endl;
    }
    return 0;
}
```