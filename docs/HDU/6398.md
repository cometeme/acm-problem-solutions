# 6398. Pizza Hub

> time limit: 3000ms | memory limit: 131072kb

Coffee Chicken has started a new restaurant named Pizza Hu...b! It provides various styles of pizzas, hamburgers, sandwiches, coffee, chickens and many other awesome Western cuisines. Welcome to Pizza Hub after this Multi-University Training Contest!

Since the pizzas are so exquisite, it is never a bad thing to design nice paper pads for them. The pizzas provided in Pizza Hub are sliced into triangles. The rectangular-shaped paper pads are cut from a paper strip of fixed width which is long enough. The pizza should be placed entirely on the pad; however, their borders are allowed to touch. Also, you are allowed to rotate the pizza.

As the customized paper strip is rather expensive, minimizing the size of the pizza pad can save a lot of money. Can you determine the minimum possible height of the pizza pad, given the width of the paper strip? The following picture illustrates the first sample test case.

![example](/assets/6398.png)

##### Input

The first line of the input is a single integer $T$ ($1 \leq T \leq 50000$), the number of test cases.

Each test case is a single line of seven integers $x_1$ , $y_1$ , $x_2$ , $y_2$ , $x_3$ , $y_3$ ($0 \leq x_1,y_1,x_2,y_2,x_3,y_3 \leq 10000$) and $w$ ($1 \leq w \leq 10000$), where $(x_1,y_1)$, $(x_2,y_2)$ and $(x_3,y_3)$ are Cartesian coordinates of the vertices of the pizza, and $w$ is the width of the strip. It is guaranteed that the three vertices are not collinear.
 
##### Output

For each test case, display the minimum height of the pizza pad with an absolute or relative error of no more than 10âˆ’6. If it is impossible to make a pizza pad, display ğš’ğš–ğš™ğš˜ğšœğšœğš’ğš‹ğš•ğš instead.

##### Example 

Input
```text
2
0 0 3 0 0 4 10
0 0 3 0 0 4 1
```
Output
```text
2.400000000
impossible
```

#### é¢˜æ„

ç»™ä½ ä¸€ä¸ªå®½åº¦ä¸º $w$ ï¼Œé•¿åº¦æ— é™çš„æŠ«è¨çº¸ï¼Œå’Œä¸€å—ä¸‰è§’å½¢çš„æŠ«è¨ã€‚è¾“å…¥ä¸‰è§’å½¢æŠ«è¨ä¸‰ä¸ªé¡¶ç‚¹çš„ç›¸å¯¹åæ ‡ã€‚ç°åœ¨è¦æ±‚å¹³è¡Œäºåº•è¾¹è£ä¸‹ä¸€å—å°½å¯èƒ½å°çš„æŠ«è¨çº¸ï¼Œä½¿å¾—èƒ½å¤Ÿå°†æ•´ä¸ªæŠ«è¨æ”¾åœ¨ä¸Šé¢ï¼Œé—®è‡³å°‘éœ€è¦å¤šé•¿çš„æŠ«è¨çº¸ã€‚å¦‚æœä¸å­˜åœ¨ç­”æ¡ˆï¼Œåˆ™è¾“å‡º `impossible` ã€‚

#### è§£æ³•

ä¸ºäº†èƒ½å¤Ÿå°½å¯èƒ½è®©æœ€ç»ˆçš„é•¿åº¦å˜çŸ­ï¼Œé¦–å…ˆå¾ˆå®¹æ˜“è¯æ˜ï¼šæŠ«è¨çš„ä¸‰ä¸ªé¡¶ç‚¹ä¸­ï¼Œä¸€å®šè‡³å°‘æœ‰ä¸€ä¸ªé¡¶ç‚¹ä¼šåœ¨æŠ«è¨çº¸çš„åº•è¾¹ä¸Šã€‚

ä¸è¿‡è¿™ä¸ªç»“è®ºå¹¶ä¸å¤Ÿå¼ºï¼Œå®é™…ä¸Šè¿™ä¸ªç»“è®ºå¯ä»¥è¿›ä¸€æ­¥å¼ºåŒ–ï¼šæŠ«è¨çš„ä¸‰ä¸ªé¡¶ç‚¹ä¸­ï¼Œå¿…å®šæœ‰ä¸€ä¸ªé¡¶ç‚¹ä¼šåœ¨æŠ«è¨çº¸çš„å·¦ä¸‹è§’ (åœ¨å³ä¸‹è§’çš„æƒ…å†µç­‰ä»·äºåœ¨å·¦ä¸‹è§’) ï¼Œè¿™æ ·æ‰æ˜¯æœ€ä¼˜è§£ã€‚

è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ†åˆ«æšä¸¾ä¸‰ä¸ªé¡¶ç‚¹åœ¨å·¦ä¸‹è§’çš„æƒ…å†µï¼Œè€Œå›ºå®šé¡¶ç‚¹åï¼Œæˆ‘ä»¬å†æšä¸¾å®ƒç›¸é‚»ä¸¤æ¡è¾¹åœ¨ä¸Š/ä¸‹çš„æƒ…å†µï¼Œå°±å¯ä»¥å¾—åˆ°æ‰€æœ‰çš„å¯èƒ½ã€‚æœ€åæˆ‘ä»¬åœ¨æ‰€æœ‰æƒ…å†µ (æ€»å…±åªæœ‰ 6 ç§) çš„é«˜åº¦ä¸­é€‰å‡ºæœ€å°å€¼ï¼Œå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆã€‚å¦‚æœå¾—åˆ°çš„ç­”æ¡ˆä¸º $INF$ ï¼Œé‚£ä¹ˆè¯´æ˜æ— æ³•å°†æŠ«è¨æ”¾å…¥ï¼Œæ­¤æ—¶è¾“å‡º `impossible` ã€‚æœ€ç»ˆçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ ã€‚

#### ä»£ç 

```cpp
#include <iostream> // C++ I/O
#include <string>   // C++ string
#include <fstream>  // File I/O
#include <sstream>  // String stream I/O
#include <iomanip>  // C++ I/O manipulator

#include <cstdlib> // C library
#include <cstdio>  // C I/O
#include <ctime>   // C time
#include <cmath>   // Math library
#include <cstring> // C strings

#include <vector>    // Vector
#include <queue>     // Queue
#include <stack>     // Stack
#include <map>       // Map
#include <set>       // Set
#include <bitset>    // Bitset
#include <algorithm> // Algorithms

using namespace std;

#define INF 1e11
#define EPS 1e-8

typedef long long ll;
typedef unsigned long long ull;

#define memclr(_var) memset(_var, 0, sizeof(_var))
#define maximize(_var, _cur) _var = max(_var, _cur)
#define minimize(_var, _cur) _var = min(_var, _cur)
#define reps(_var, _begin, _end, _step) for (int _var = (_begin); _var <= (_end); _var += (_step))
#define reps_(_var, _end, _begin, _step) for (int _var = (_end); _var >= (_begin); _var -= (_step))
#define rep(_var, _begin, _end) reps(_var, _begin, _end, 1)
#define rep_(_var, _end, _begin) reps_(_var, _end, _begin, 1)

inline int read()
{
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9')
        f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

const double PI = acos(-1.0);

inline double sqr(double x)
{
    return x * x;
}

inline double dis2(double x1, double y1, double x2, double y2)
{
    return sqr(x2 - x1) + sqr(y2 - y1);
}

// a, b, c is dis2
inline double caltheta(double a, double b, double c)
{
    return acos((a + b - c) / (2 * sqrt(a * b)));
}

double d[5], d2[5];
double w, w2;

inline double calhight()
{
    rep (i, 0, 2)
        d[i] = sqrt(d2[i]);

    // x0 = y0 = 0
    double x1, y1;

    if (d[0] <= w)
        x1 = d[0], y1 = 0;
    else
        x1 = w, y1 = sqrt(d2[0] - w2);
    
    double alpha = atan(y1 / x1);
    double beta = caltheta(d2[0], d2[1], d2[2]);
    double theta = alpha + beta;

    double x2 = d[1] * cos(theta);
    double y2 = d[1] * sin(theta);

    // cannot put in
    if (x2 < -EPS || x2 > w + EPS)
        return INF;
    
    return max(y1, y2);
}

int main(int argc, char *argv[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int T = read();

    rep (_, 1, T)
    {
        double x1 = read(), y1 = read(), x2 = read(), y2 = read(), x3 = read(), y3 = read();
        w = read();
        w2 = sqr(w);

        d2[0] = dis2(x1, y1, x2, y2);
        d2[1] = dis2(x1, y1, x3, y3);
        d2[2] = dis2(x2, y2, x3, y3);

        sort(d2, d2 + 3);
        
        double res = INF;

        do
        {
            minimize(res, calhight());
        } while (next_permutation(d2, d2 + 3));

        if (res == INF)
            puts("impossible");
        else
            printf("%.10f\n", res);
    }

    return 0;
}
```